// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: query.sql

package db

import (
	"context"
)

const createAccount = `-- name: CreateAccount :exec
INSERT INTO accounts (
  address, balance
) VALUES (
  ?, ?
)
`

type CreateAccountParams struct {
	Address string `json:"address"`
	Balance int64  `json:"balance"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) error {
	_, err := q.db.ExecContext(ctx, createAccount, arg.Address, arg.Balance)
	return err
}

const createTx = `-- name: CreateTx :exec
INSERT INTO txs (
  payer, payee, amount
) VALUES (
  ?, ?, ?
)
`

type CreateTxParams struct {
	Payer  string `json:"payer"`
	Payee  string `json:"payee"`
	Amount int64  `json:"amount"`
}

func (q *Queries) CreateTx(ctx context.Context, arg CreateTxParams) error {
	_, err := q.db.ExecContext(ctx, createTx, arg.Payer, arg.Payee, arg.Amount)
	return err
}

const getAccountBalance = `-- name: GetAccountBalance :one
SELECT balance FROM accounts WHERE address = ?
`

func (q *Queries) GetAccountBalance(ctx context.Context, address string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getAccountBalance, address)
	var balance int64
	err := row.Scan(&balance)
	return balance, err
}

const getAccounts = `-- name: GetAccounts :many
SELECT address, balance
FROM accounts
ORDER BY address
LIMIT 500
`

func (q *Queries) GetAccounts(ctx context.Context) ([]Account, error) {
	rows, err := q.db.QueryContext(ctx, getAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Account{}
	for rows.Next() {
		var i Account
		if err := rows.Scan(&i.Address, &i.Balance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTxs = `-- name: GetTxs :many
SELECT height, payer, payee, amount
FROM txs
ORDER BY height desc
LIMIT 500
`

func (q *Queries) GetTxs(ctx context.Context) ([]Tx, error) {
	rows, err := q.db.QueryContext(ctx, getTxs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tx{}
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.Height,
			&i.Payer,
			&i.Payee,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccount = `-- name: UpdateAccount :exec
INSERT INTO accounts (address, balance)
VALUES (?, ?)
ON CONFLICT(address)
DO UPDATE
SET balance = balance + excluded.balance
`

type UpdateAccountParams struct {
	Address string `json:"address"`
	Balance int64  `json:"balance"`
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) error {
	_, err := q.db.ExecContext(ctx, updateAccount, arg.Address, arg.Balance)
	return err
}
